#!/bin/bash

source ../../lib_bash.sh

declare -a data
data=(0 0 0 0 0)
error_type=(0 0 0 0 0)
input_file_check=$1
output_file_check="output.txt"
output_file_check_after_find="output2.txt"

if [ -z "$input_file_check" ] ; then 
	echo "failed"	
	exit 0
fi

func_handler()
{
		read line < "$output_file_check_after_find"

		error_type[0]=$(echo $1|sed 's/_/ /')
		error_type[1]=$(echo $2|sed 's/_/ /')
		error_type[2]=$(echo $3|sed 's/_/ /')
        #check key of error return 0 or 1
        data[0]=$(echo $line|grep "${error_type[0]}"|wc -l)
        data[1]=$(echo $line|grep "${error_type[1]}"|wc -l)
        data[2]=$(echo $line|grep "${error_type[2]}"|wc -l)
        sum=$(( ${data[0]} + ${data[1]} + ${data[2]} ))
		if [ $sum == "0" ]; then 
			echo "None None None None"
			return 127
		fi
		local header=$(echo $line|awk '{print $2}'|cut -d':' -f1)
        case $sum in
				${data[0]})
                        # unknown type name error
						header=$(echo $line|awk '{print $2}'|cut -d':' -f1)
            			            ps=$(echo $line|awk '{print $0}'|cut -d':' -f2)
						er=$(echo $line|awk '{for ( i = 1; i <= NF; i++ )
            			            if ( $i=="name" ) print $(i+1)}')
            			            er1=$(echo $line|awk '{for ( i = 1; i <= NF; i++ )
            			            if ( $i=="function" ) print $(i+1)}')
						#variable detect missing pthread flags
            			            er2=$(echo $line|awk '{for ( i = 1; i <= NF; i++ )
            			            if ( $i=="reference" ) print $(i+2)}')
						if [ -z $er2 ]; then 
							temp=10; 
						else 
							error_type[0]="reference";
							ps="0"
						fi
						out_data=$(echo "$header ${error_type[0]} $er $er1 $er2 $ps"|wc -w)
						if [ $out_data -gt 4 ]; then
							echo "None None None None"
							return 127
						else
							echo "$header ${error_type[0]} $er $er1 $er2 $ps"
						fi
            			            ;;
                ${data[1]})
                        # expected character ";"
                        er=$(echo $line|awk '{for ( i = 1; i <= NF; i++ )
                        if ( $i=="before" ) print $(i+1)}')
                        er1=$(echo $line|awk -v mvar=${error_type[1]} '{for ( i = 1; i <= NF; i++ )
                        if ( $i==mvar ) print $(i+1)}')
                        ps=$(echo $line|awk '{print $0}'|cut -d':' -f2)
                        echo "$header ${error_type[1]} $er1 $ps"
                        ;;
                ${data[2]})
                        # undeclared MACRO or variable
                        er=$(echo $line|awk -v mvar=${error_type[2]} '{for ( i = 1; i <= NF; i++ )
                        if ( $i==mvar ) print $(i-1)}')
                        ps=$(echo $line|awk '{print $0}'|cut -d':' -f2)
                        echo "$header ${error_type[2]} $er $ps"
                        ;;
             esac
}

function test_get_lib_flag()
{
	get_library_flag_from_name "printk"
	get_library_flag_from_name "printf"
	get_library_flag_from_name "kill"
	get_library_flag_from_name "SIGINT"
	get_library_flag_from_name "memset"
	get_library_flag_from_name "pthread_join"

}

function test_add_lib_flag()
{
	local ret 
	add_lib_flag $1 $2
	if [[ $? != 0 ]]; then 
		echo "error at add_lib_flag for $1"
		return 127
	fi
	return 0
}

function test_add_semicolon()
{
	add_semicolon $1
	
	if [[ $? != 0 ]]; then 
		echo "add semicolon failed"
	fi

}

function check_un_ex_und()
{
	local ret ret2
	if [[ $1 == "warning" ]]; then 
		awk '/warning:/ {print NR,$0}' $output_file_check > "$output_file_check_after_find"
		ret=$(func_handler implicit kkka kkkk)
	elif [[ $1 == "error" ]]; then 
		echo "this option is error"
		awk '/error:/ {print NR,$0}' $output_file_check > "$output_file_check_after_find"
#func_handler unknown expected undeclared
		ret=$(func_handler unknown expected undeclared)
	else 

		awk '/undefined reference/ {print NR,$0}' $output_file_check > "$output_file_check_after_find"
		ret=$(func_handler undefined_reference anh_tuan anh)

	fi

	IFS=' ' read -r -a array <<< "$ret"
	
	local length=${#array[2]} 
	(( length -=2 ))	
	local tmp_var=$(echo ${array[2]:1:$length})

	test_add_lib_flag "${array[0]}" $tmp_var
	ret2=$?
#echo "ret from test_add_lib_flag is $?"

	if [[ $ret2 != 0 ]]; then 
#echo "failed in check un ex und"
		return 127	
	fi

	rm  -f $output_file_check $output_file_check_after_find 

}
function rebuild()
{   
	local input_file=$1
	echo "$oFLAG"
	make FLAGS="$oFLAGS" FILE_IN="$input_file" &> "$output_file_check"
}

prepare_header $db_file
if [[ $? != 0 ]]; then 
	echo "prepare header failed"
else 
	echo "complete get db.txt"
fi

function mloop()
{
	local ret
	rebuild "main.c"

	array=( "error" "warning" "handler" )
	for i in "${array[@]}"
	do
		while : ; do 
		check_un_ex_und "$i"
		ret=$?
		echo "ret after check un_ex_und is $?"
		if [[ $ret != 0 ]]; then 
			echo "skip this warning, this warning have supported yet"		
			break
		fi

		head -n 6 output.c
		cp output.c output2.c
		rebuild "output2.c"

		done ;	
	done

	make clean_trash

}

mloop

